# K. Медиана объединения-2
# Дано N упорядоченных по неубыванию последовательностей целых чисел (т.е. каждый следующий элемент больше либо равен предыдущему), в каждой из последовательностей ровно L элементов.
# Для каждых двух последовательностей выполняют следующую операцию: объединяют их элементы (в объединенной последовательности каждое число будет идти столько раз, сколько раз оно встречалось суммарно в объединяемых последовательностях), упорядочивают их по неубыванию и смотрят, какой элемент в этой последовательности из 2L элементов окажется на месте номер L (этот элемент называют левой медианой).
# Напишите программу, которая для каждой пары последовательностей выведет левую медиану их объединения.

# Формат ввода
# Сначала вводятся числа N и L (2 ≤ N ≤ 200, 1 ≤ L ≤ 50000). В следующих N строках задаются параметры, определяющие последовательности.
# Каждая последовательность определяется пятью целочисленными параметрами: x1, d1, a, c, m.
# Элементы последовательности вычисляются по следующим формулам: x1 нам задано, а для всех i от 2 до L: xi = x[i–1]+d[i–1].
# Последовательность di определяется следующим образом: d1 нам задано, а для i ≥ 2 di = ((a*d[i–1]+c) mod m), где mod – операция получения остатка от деления (a*d[i–1]+c) на m.
# Для всех последовательностей выполнены следующие ограничения: 1 ≤ m ≤ 40000, 0 ≤ a < m, 0≤c<m, 0≤d1<m. Гарантируется, что все члены всех последовательностей по модулю не превышают 10^9.

# Формат вывода
# В первой строке выведите медиану объединения 1-й и 2-й последовательностей, во второй строке — объединения 1-й и 3-й, и так далее, в (N‑1)-ой строке — объединения 1-й и N-ой последовательностей, далее медиану объединения 2-й и 3-й, 2-й и 4-й, и т.д. до 2-й и N-ой, затем 3-й и 4-й и так далее. В последней строке должна быть выведена медиана объединения (N–1)-й и N-ой последовательностей.

# Решение из разбора

def left_bin_search(left, right, value, seq):
	while left < right:
		middle = (left + right) // 2
		if seq[middle] >= value:
			right = middle
		else:
			left = middle + 1
	return left

# сколько в последовательности элементов меньше value
def count_less(value, arr):
	i = left_bin_search(0, len(arr) - 1, value, arr)
	if arr[i] < value:
		return len(arr)
	return i

# сколько в последовательности элементов больше value
def count_greater(value, arr):
	return len(arr) - count_less(value + 1, arr)

def get_median(seq1, seq2, l):
	left = min(seq1[0], seq2[0])
	right = max(seq1[-1], seq2[-1])
	while left < right:
		middle = (left + right) // 2
		# количество элементов меньше middle в обоих последовательностях
		less = count_less(middle, seq1) + count_less(middle, seq2)
		# количество элементов больше middle в обоих последовательностях
		greater = count_greater(middle, seq1) + count_greater(middle, seq2)
		if less <= l - 1 and greater <= l:
			return middle
		if greater > l:
			left = middle + 1
		if less > l - 1:
			right = middle - 1
	return left

def generate_seq(x1, d, a, c, m, l):
	seq = [0] * l
	seq[0] = x1
	for i in range(1, l):
		seq[i] = seq[i - 1] + d
		d = ((a * d + c) % m)
	return seq

n, l = map(int, input().split())
seq = []
for i in range(n):
	x1, d1, a, c, m = map(int, input().split())
	seq.append(generate_seq(x1, d1, a, c, m, l))

for i in range(n):
	for j in range(i + 1, n):
		print(get_median(seq[i], seq[j], l))
