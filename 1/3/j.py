# J. Пробежки по Манхэттену
# Дороги Нью-Манхэттена устроены следующим образом. С юга на север через каждые сто метров проходит авеню, с запада на восток через каждые сто метров проходит улица. Авеню и улицы нумеруются целыми числами. Меньшие номера соответствуют западным авеню и южным улицам.
# Таким образом, можно построить прямоугольную систему координат так, чтобы точка (x, y) лежала на пересечении x-ой авеню и y-ой улицы.
# Легко заметить, что для того, чтобы в Нью-Манхэттене дойти от точки (x1, y1) до точки (x2, y2) нужно пройти |x2 − x1| + |y2 − y1| кварталов.
# Эта величина называется манхэттенским расстоянием между точками (x1, y1) и (x2, y2).
# Миша живет в Нью-Манхэттене и каждое утро делает пробежку по городу. Он выбегает из своего дома, который находится в точке (0, 0) и бежит по случайному маршруту.
# Каждую минуту Миша либо остается на том же перекрестке, что и минуту назад, или перемещается на один квартал в любом направлении.
# Чтобы не заблудиться Миша берет с собой навигатор, который каждые t минут говорит Мише, в какой точке он находится. К сожалению, навигатор показывает не точное положение Миши, он может показать любую из точек, манхэттенское расстояние от которых до Миши не превышает d.
# Через t × n минут от начала пробежки, получив n-е сообщение от навигатора, Миша решил, что пора бежать домой. Для этого он хочет понять, в каких точках он может находиться. Помогите Мише сделать это.

# Формат ввода
# Первая строка входного файла содержит числа t, d и n (1 ≤ t ≤ 100, 1 ≤ d ≤ 100, 1 ≤ n ≤ 100).
# Далее n строк описывают данные, полученные от навигатора. Строка номер i содержит числа xi и yi — данные, полученные от навигатора через ti минут от начала пробежки.

# Формат вывода
# В первой строке выходного файла выведите число m — число точек, в которых может находиться Миша. Далее выведите m пар чисел — координаты точек. Точки можно вывести в произвольном порядке.
# Гарантируется, что навигатор исправен и что существует по крайней мере одна точка, в которой может находиться Миша.

# Решение из разбора

def	extend_rect(rect, d):
	x_min, x_max, y_min, y_max = rect
	return x_min - d, x_max + d, y_min - d, y_max + d

def	intersect_rect(rect1, rect2):
	inter = max(rect1[0], rect2[0]), min(rect1[1], rect2[1]), max(rect1[2], rect2[2]), min(rect1[3], rect2[3])
	return inter

t, d, n = map(int, input().split())
# начальная точка 
position_rect = 0, 0, 0, 0
# все точки на диагоналях слева-сверху -> вниз-вправо - x + y = p
# все точки на диагоналях справа-сверху -> вниз-влево - x - y = q
for _ in range(n):
	position_rect = extend_rect(position_rect, t)
	nav_x, nav_y = map(int, input().split())
	nav_rect = nav_x + nav_y, nav_x + nav_y, nav_x - nav_y, nav_x - nav_y
	nav_rect = extend_rect(nav_rect, d)
	position_rect = intersect_rect(position_rect, nav_rect)

points = []
for x in range(position_rect[0], position_rect[1] + 1):
	for y in range(position_rect[2], position_rect[3] + 1):
		#если остаток == 0, точка лежит на пересечении авеню и улицы
		if (x + y) % 2 == 0:
			point_x = (x + y) // 2
			point_y = x - point_x
			points.append((point_x, point_y))

print(len(points))
for p in points:
	print(*p)
