# J. Медиана объединения
# Дано N упорядоченных по неубыванию последовательностей целых чисел (т.е. каждый следующий элемент больше либо равен предыдущему), в каждой из последовательностей ровно L элементов.
# Для каждых двух последовательностей выполняют следующую операцию: объединяют их элементы (в объединенной последовательности каждое число будет идти столько раз, сколько раз оно встречалось суммарно в объединяемых последовательностях), упорядочивают их по неубыванию и смотрят, какой элемент в этой последовательности из 2L элементов окажется на месте номер L (этот элемент называют левой медианой).
# Напишите программу, которая для каждой пары последовательностей выведет левую медиану их объединения.

# Формат ввода
# Сначала вводятся числа N и L (2 ≤ N ≤ 100, 1 ≤ L ≤ 300). В следующих N строках задаются последовательности. Каждая последовательность состоит из L чисел, по модулю не превышающих 30000.

# Формат вывода
# В первой строке выведите медиану объединения 1-й и 2-й последовательностей, во второй строке — объединения 1-й и 3-й, и так далее, в (N‑1)-ой строке — объединения 1-й и N-ой последовательностей, далее медиану объединения 2-й и 3-й, 2-й и 4-й, и т.д. до 2-й и N-ой, затем 3-й и 4-й и так далее. В последней строке должна быть выведена медиана объединения (N–1)-й и N-ой последовательностей.

# Решение из разбора

def left_bin_search(left, right, value, seq):
	while left < right:
		middle = (left + right) // 2
		if seq[middle] >= value:
			right = middle
		else:
			left = middle + 1
	return left

# сколько в последовательности элементов меньше value
def count_less(value, arr):
	i = left_bin_search(0, len(arr) - 1, value, arr)
	if arr[i] < value:
		return len(arr)
	return i

# сколько в последовательности элементов больше value
def count_greater(value, arr):
	return len(arr) - count_less(value + 1, arr)

def get_median(seq1, seq2, l):
	left = min(seq1[0], seq2[0])
	right = max(seq1[-1], seq2[-1])
	while left < right:
		middle = (left + right) // 2
		# количество элементов меньше middle в обоих последовательностях
		less = count_less(middle, seq1) + count_less(middle, seq2)
		# количество элементов больше middle в обоих последовательностях
		greater = count_greater(middle, seq1) + count_greater(middle, seq2)
		if less <= l - 1 and greater <= l:
			return middle
		if greater > l:
			left = middle + 1
		if less > l - 1:
			right = middle - 1
	return left

n, l = map(int, input().split())
seq = [None] * n
for i in range(n):
	seq[i] = list(map(int, input().split()))

for i in range(n):
	for j in range(i + 1, n):
		print(get_median(seq[i], seq[j], l))
